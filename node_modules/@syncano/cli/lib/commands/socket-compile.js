'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _debug = require('../utils/debug');

var _debug2 = _interopRequireDefault(_debug);

var _spinner = require('./helpers/spinner');

var _printTools = require('../utils/print-tools');

var _dateUtils = require('../utils/date-utils');

var _errors = require('../utils/errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const { debug } = (0, _debug2.default)('cmd-socket-deploy');

const pendingUpdates = {};

class SocketCompile {
  constructor(context) {
    this.context = context;
    this.session = context.session;
    this.Socket = context.Socket;
  }

  run([socketName, cmd]) {
    var _this = this;

    return _asyncToGenerator(function* () {
      _this.cmd = cmd;

      if (socketName) {
        debug(`Deploying Socket: ${socketName}`);
        const msg = (0, _printTools.p)(2)(`${_chalk2.default.magenta('getting sockets:')} ${(0, _dateUtils.currentTime)()}`);
        const spinner = new _spinner.SimpleSpinner(msg).start();
        const socket = yield _this.Socket.get(socketName);
        spinner.stop();

        if (!socket.existLocally) {
          (0, _printTools.echo)();
          (0, _printTools.error)(4)(`Socket ${_chalk2.default.cyan(socketName)} cannot be found!`);
          (0, _printTools.echo)();
          process.exit(1);
        }
        _this.socketList = [socket];
      } else {
        const msg = (0, _printTools.p)(2)(`${_chalk2.default.magenta('getting sockets:')} ${(0, _dateUtils.currentTime)()}`);
        const spinner = new _spinner.SimpleSpinner(msg).start();
        _this.socketList = yield _this.Socket.list();
        spinner.stop();
      }

      const configs = {};

      try {
        let index;
        for (index in _this.socketList) {
          const socket = _this.socketList[index];
          if (!socket.isDependency()) {
            yield _this.compileSocket(socket, configs[socket.name]);
          }
        }

        (0, _printTools.echo)();
      } catch (err) {
        if (err.response && err.response.data && err.response.data.detail) {
          (0, _printTools.error)(4)(err.response.data.detail);
        } else {
          (0, _printTools.error)(4)(err);
        }
        process.exit(1);
      }
    })();
  }

  compileSocket(socket, config) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      debug(`compileSocket: ${socket.name}`);
      const deployTimer = new _dateUtils.Timer();
      const msg = (0, _printTools.p)(4)(`${_chalk2.default.magenta('socket compile:')} ${(0, _dateUtils.currentTime)()} ${_chalk2.default.cyan(socket.name)}`);
      const spinner = new _spinner.SimpleSpinner(msg).start();

      // We have co count here updates
      if (!pendingUpdates[socket.name]) {
        pendingUpdates[socket.name] = 0;
      }

      pendingUpdates[socket.name] += 1;
      if (pendingUpdates[socket.name] > 1) {
        spinner.stop();
        _this2.mainSpinner.start();
        debug(`not updating, update pending: ${pendingUpdates[socket.name]}`);
        return;
      }

      const socketNameStr = `${_chalk2.default.cyan(socket.name)}`;

      // Let's compile and update if it is not hot mode
      try {
        yield socket.createAllZips();
        spinner.stop();
        const status = _chalk2.default.grey('socket compiled:');
        const duration = _chalk2.default.dim(deployTimer.getDuration());
        (0, _printTools.echo)(6)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr} ${duration}`);
      } catch (err) {
        debug(err);
        spinner.stop();
        if (err instanceof _errors.CompileError) {
          const status = _chalk2.default.red('    compile error:');
          if (err.traceback) {
            (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr}\n\n${err.traceback.split('\n').map(function (line) {
              return (0, _printTools.p)(8)(line);
            }).join('\n')}`);
          } else {
            (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr} Error while executing 'build' script!`);
          }
        } else {
          const status = _chalk2.default.red('socket sync error:');
          if (err.message) {
            (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr} ${_chalk2.default.red(err.message)}`);
          } else {
            (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr}`);
            (0, _printTools.error)(err);
          }
        }
      }
    })();
  }

  getSocketToUpdate(fileName) {
    return this.localSockets.find(socket => socket.isSocketFile(fileName));
  }

  static bail() {
    (0, _printTools.echo)();
    process.exit(1);
  }

  static printUpdateSuccessful(socketName, updateStatus, deployTimer) {
    debug('printUpdateSuccessful', socketName, updateStatus);
    const duration = _chalk2.default.dim(deployTimer.getDuration());
    const socketNameStr = `${_chalk2.default.cyan(socketName)}`;

    if (updateStatus.status === 'ok') {
      const status = _chalk2.default.grey('socket synced:');
      (0, _printTools.echo)(6)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr} ${duration}`);
    } else if (updateStatus.status === 'stopped') {
      const status = _chalk2.default.grey('socket in sync:');
      (0, _printTools.echo)(5)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr} ${duration}`);
    } else if (updateStatus.status === 'error') {
      const errDetail = _chalk2.default.red(updateStatus.message.error);
      const status = _chalk2.default.red('socket not synced:');
      (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr} ${duration} ${errDetail}`);
    } else {
      const status = _chalk2.default.red('socket not synced:');
      (0, _printTools.echo)(2)(`${status} ${(0, _dateUtils.currentTime)()} ${socketNameStr} ${duration}`);
    }
  }
}
exports.default = SocketCompile;
module.exports = exports['default'];
//# sourceMappingURL=socket-compile.js.map