'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HostingFile = exports.default = undefined;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _formData = require('form-data');

var _formData2 = _interopRequireDefault(_formData);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _prettyBytes = require('pretty-bytes');

var _prettyBytes2 = _interopRequireDefault(_prettyBytes);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _md = require('md5');

var _md2 = _interopRequireDefault(_md);

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _debug = require('../debug');

var _debug2 = _interopRequireDefault(_debug);

var _utils = require('./utils');

var _printTools = require('../../utils/print-tools');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const { debug } = (0, _debug2.default)('utils-hosting');

class HostingFile {
  loadRemote(fileRemoteData) {
    debug('loadRemote');
    this.id = fileRemoteData.id;
    this.instanceName = fileRemoteData.instanceName;
    this.path = decodeURIComponent(fileRemoteData.path);
    this.checksum = fileRemoteData.checksum;
    this.size = fileRemoteData.size;
    return this;
  }
  loadLocal(fileLocalData) {
    debug('loadLocal');
    this.localPath = fileLocalData.localPath;
    this.path = fileLocalData.path;
    this.checksum = (0, _md2.default)(_fs2.default.readFileSync(this.localPath));
    this.size = _fs2.default.statSync(this.localPath).size;
    return this;
  }
}

class Hosting {
  constructor(hostingName) {
    debug('Hosting.constructor', hostingName);

    this.name = hostingName;
    this.path = null;

    this.existRemotely = null;
    this.existLocally = null;

    this.hostingURL = `/v2/instances/${_session2.default.project.instance}/hosting/`;
    this.editHostingURL = `https://${_session2.default.getHost()}${this.hostingURL}${this.name}/`;
    this.hostingHost = _session2.default.getHost() === 'api.syncano.rocks' ? 'syncano.ninja' : 'syncano.site';
    this.config = {};

    // Remote state
    this.remote = {
      domains: []
    };

    this.loadLocal();
  }

  static add(params) {
    return _asyncToGenerator(function* () {
      const configParams = {
        src: params.src,
        config: {
          browser_router: params.browser_router || false
        }
      };
      _session2.default.settings.project.addHosting(params.name, configParams);

      const hostingURL = `/v2/instances/${_session2.default.project.instance}/hosting/`;
      const addHostingURL = `https://${_session2.default.getHost()}${hostingURL}`;

      const domains = [params.name];
      if (params.cname) {
        domains.push(params.cname);
      }

      const paramsToAdd = {
        name: params.name,
        config: {
          browser_router: params.browser_router
        },
        domains
      };

      const response = yield _axios2.default.request({
        url: addHostingURL,
        method: 'POST',
        data: paramsToAdd,
        headers: {
          'X-Api-Key': _session2.default.settings.account.getAuthKey()
        }
      });
      return response.data;
    })();
  }

  hasCNAME(cname) {
    return this.remote.domains.indexOf(cname) > -1;
  }

  updateHosting() {
    const params = {
      src: this.src,
      cname: this.cname,
      config: {
        browser_router: this.browser_router || false
      }
    };
    if (!this.cname) {
      delete params.cname;
    }
    _session2.default.settings.project.updateHosting(this.name, params);
  }

  configure(params) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const domains = _this.remote.domains;
      if (params.cname && domains.indexOf(params.cname) < 0) {
        domains.push(params.cname);
      }

      if (params.removeCNAME) {
        _this.cname = null;
        const cnameToRemoveIndex = domains.indexOf(params.removeCNAME);
        if (cnameToRemoveIndex > -1) {
          domains.splice(cnameToRemoveIndex, 1);
        }
      }

      _this.cname = params.cname;
      _this.domains = domains;
      _this.config.browser_router = params.browser_router;
      _this.updateHosting();

      const paramsToUpdate = {
        name: _this.name,
        config: _this.config,
        domains
      };

      const response = yield _axios2.default.request({
        url: _this.editHostingURL,
        method: 'PATCH',
        data: paramsToUpdate,
        headers: {
          'X-Api-Key': _session2.default.settings.account.getAuthKey()
        }
      });
      return _this.setRemoteState(response.data);
    })();
  }

  deploy() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      debug('deploy');

      if (!_this2.existRemotely) {
        debug('adding hosting');
        return Hosting.add({
          name: _this2.name,
          src: _this2.src
        });
      }

      debug('patching hosting');
      // TODO: not optimal
      const paramsToUpdate = {
        name: _this2.name,
        domains: _this2.domains,
        config: _this2.config,
        auth: _this2.auth || {}
      };

      const response = yield _axios2.default.request({
        url: _this2.editHostingURL,
        method: 'PATCH',
        data: paramsToUpdate,
        headers: {
          'X-Api-Key': _session2.default.settings.account.getAuthKey()
        }
      });

      return _this2.setRemoteState(response.data);
    })();
  }

  delete() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      yield _axios2.default.request({
        url: _this3.editHostingURL,
        method: 'DELETE',
        headers: {
          'X-Api-Key': _session2.default.settings.account.getAuthKey()
        }
      });
      _session2.default.settings.project.deleteHosting(_this3.name);
      return _this3;
    })();
  }

  static get(hostingName) {
    debug(`get ${hostingName}`);
    const hosting = new Hosting(hostingName);
    return hosting.loadRemote();
  }

  static listFromProject() {
    return _session2.default.settings.project.listHosting();
  }

  // list all hostings (mix of locally definde and installed on server)
  static list() {
    return _asyncToGenerator(function* () {
      debug('list()');
      const projectHostings = Hosting.listFromProject();
      debug('projectHostings', projectHostings);
      return _bluebird2.default.all(projectHostings.map(function (hosting) {
        return Hosting.get(hosting.name);
      }));
    })();
  }

  static getDirectories() {
    const excluded = ['node_modules', 'src', 'syncano'];

    function notExcluded(dirname) {
      if (dirname.startsWith('.')) {
        return;
      }
      if (excluded.indexOf(dirname) !== -1) {
        return;
      }
      return dirname;
    }

    return _fs2.default.readdirSync(process.cwd()).filter(file => {
      const dirs = [];
      if (_fs2.default.statSync(`${process.cwd()}/${file}`).isDirectory()) {
        dirs.push(file);
      }
      return dirs.find(notExcluded);
    });
  }

  setRemoteState(hosting) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      debug('setRemoteState', hosting.name);
      if (hosting && typeof hosting === 'object') {
        _this4.existRemotely = true;
        _this4.remote.name = hosting.name;
        _this4.remote.description = hosting.description;
        _this4.remote.domains = hosting.domains;
        _this4.remote.config = hosting.config || {};
        _this4.remote.config.browser_router = hosting.config.browser_router || false;
        _this4.remote.auth = hosting.auth;
        _this4.isUpToDate = yield _this4.areFilesUpToDate();
      } else {
        _this4.existRemotely = false;
        _this4.error = hosting;
      }
      return _bluebird2.default.resolve();
    })();
  }

  loadRemote() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      debug('loadRemote()');
      try {
        const hosting = yield _this5.getRemote();
        yield _this5.setRemoteState(hosting);
      } catch (err) {
        _this5.existRemotely = false;
      }
      return _this5;
    })();
  }

  loadLocal() {
    debug('loadLocal()');
    const localHostingSettings = _session2.default.settings.project.getHosting(this.name);

    if (localHostingSettings) {
      if (Object.keys(localHostingSettings).length > 0) {
        this.existLocally = true;
        this.src = localHostingSettings.src;
        this.cname = localHostingSettings.cname;
        this.auth = localHostingSettings.auth;
        this.path = _path2.default.join(_session2.default.projectPath, this.src, _path2.default.sep);
        this.url = this.getURL(this.name);

        this.config = localHostingSettings.config || {};
      }
    }
  }

  getURL() {
    return `https://${this.name}--${_session2.default.project.instance}.${this.hostingHost}`;
  }

  encodePath(pathToEncode) {
    return pathToEncode.split(_path2.default.sep).map(part => encodeURI(part)).join(_path2.default.sep);
  }

  decodePath(pathToEncode) {
    return pathToEncode.split('/').map(part => decodeURI(part)).join('/');
  }

  // Verify local file if it should be created or updated
  getFilesToUpload(file, remoteFiles) {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      debug('getFilesToUpload');
      const fileToUpdate = _lodash2.default.find(remoteFiles, { path: file.path });
      const payload = new _formData2.default();
      payload.append('file', _fs2.default.createReadStream(file.localPath));
      payload.append('path', _this6.encodePath(file.path));

      let singleFile = null;

      if (fileToUpdate) {
        const remoteChecksum = fileToUpdate.checksum;
        const localChecksum = file.checksum;

        // Check if checksum of the local file is the same as remote one
        if (remoteChecksum === localChecksum) {
          try {
            (0, _printTools.echo)(6)(`${_chalk2.default.green('✓')} File skipped: ${_chalk2.default.dim(file.path)}`);
          } catch (err) {
            (0, _printTools.error)(err);
          }
        } else {
          try {
            singleFile = yield _session2.default.connection.hosting.updateFile(_this6.name, fileToUpdate.id, payload);
            (0, _printTools.echo)(6)(`${_chalk2.default.green('✓')} File updated: ${_chalk2.default.dim(file.path)}`);
          } catch (err) {
            (0, _printTools.echo)(`Error while syncing (updating) ${file.path}`);
            debug(err.response.data);
          }
        }
      } else {
        // Adding (first upload) file
        try {
          singleFile = yield _session2.default.connection.hosting.uploadFile(_this6.name, payload);
          (0, _printTools.echo)(6)(`${_chalk2.default.green('✓')} File added:   ${_chalk2.default.dim(file.path)}`);
        } catch (err) {
          (0, _printTools.echo)(`Error while syncing (creating) ${file.path}`);
          debug(err.response.data);
        }
      }

      return singleFile;
    })();
  }

  // Verify remote file if it deleted
  getFilesToDelete(remoteFiles, localFiles) {
    var _this7 = this;

    debug('getFilesToDelete');

    const filesToDelete = remoteFiles.filter(file => !_lodash2.default.find(localFiles, { path: file.path }));

    return filesToDelete.map((() => {
      var _ref = _asyncToGenerator(function* (file) {
        const singleFile = yield _session2.default.connection.hosting.deleteFile(_this7.name, file.id);
        (0, _printTools.echo)(6)(`${_chalk2.default.green('✓')} File deleted: ${_chalk2.default.dim(file.path)}`);
        return singleFile;
      });

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    })());
  }

  // Files upload report
  generateUploadFilesResult(result) {
    if (!result) {
      return `\n\t${_chalk2.default.red('No files synchronized!')}\n`;
    }
    const prettyUploadSize = (0, _prettyBytes2.default)(result.uploadedSize);

    return `\n\t${_chalk2.default.cyan(result.uploadedFilesCount)} files synchronized, ${_chalk2.default.cyan(prettyUploadSize)} in total
    \t${_chalk2.default.green(this.name)} is available at: ${_chalk2.default.green(this.getURL())}\n`;
  }

  uploadFiles(files, params) {
    var _this8 = this;

    return _asyncToGenerator(function* () {
      let uploadedFilesCount = 0;
      let uploadedSize = 0;
      let promises = [];

      const localFiles = yield _this8.listLocalFiles();

      // promises for add/update operations
      yield localFiles.forEach(function (file) {
        promises.push(_this8.getFilesToUpload(file, files));
      });

      const values = yield _bluebird2.default.all(promises);
      uploadedFilesCount = 0;
      uploadedSize = 0;
      values.forEach(function (upload) {
        uploadedFilesCount += 1;
        uploadedSize += upload ? upload.size : 0;
      });

      if (params.delete) {
        // promises for deleting files
        yield _bluebird2.default.all(_this8.getFilesToDelete(files, localFiles));
      }

      return { uploadedFilesCount, uploadedSize };
    })();
  }

  // Run this to synchronize hosted files
  // first we are getting remote files
  syncFiles(params) {
    var _this9 = this;

    return _asyncToGenerator(function* () {
      debug('syncFiles()');

      if (!_fs2.default.existsSync(_this9.path)) {
        throw new Error(`Local folder ${_chalk2.default.bold(_this9.path)} doesn't exist!`);
      }

      const remoteFiles = yield _this9.listRemoteFiles();
      const result = yield _this9.uploadFiles(remoteFiles, params);
      return _this9.generateUploadFilesResult(result);
    })();
  }

  areFilesUpToDate() {
    var _this10 = this;

    return _asyncToGenerator(function* () {
      debug('areFilesUpToDate()');

      // Check if local folder exist
      if (!_fs2.default.existsSync(_this10.path)) {
        return false;
      }

      const localChecksums = yield _this10.listLocalFiles().map(function (localFile) {
        return {
          filePath: localFile.path,
          checksum: localFile.checksum
        };
      });

      const remoteChecksums = yield _this10.listRemoteFiles().map(function (remoteFile) {
        return {
          filePath: remoteFile.path,
          checksum: remoteFile.checksum
        };
      });

      return _lodash2.default.isEqual(_lodash2.default.sortBy(localChecksums, 'filePath'), _lodash2.default.sortBy(remoteChecksums, 'filePath'));
    })();
  }

  // Get list of the hostings first, then get the files list for given one
  listRemoteFiles() {
    var _this11 = this;

    return _asyncToGenerator(function* () {
      debug('listRemoteFiles()');
      const files = yield _session2.default.connection.hosting.listFiles(_this11.name);
      return _bluebird2.default.all(files.map((() => {
        var _ref2 = _asyncToGenerator(function* (file) {
          // TODO: Maybe it should be somehow done in the library not here
          file.path = _this11.decodePath(file.path);

          const hostingFile = new HostingFile(file);
          return hostingFile.loadRemote(file);
        });

        return function (_x2) {
          return _ref2.apply(this, arguments);
        };
      })()));
    })();
  }

  // Get info about hostings first, then get the files list for given one
  listLocalFiles() {
    var _this12 = this;

    return _asyncToGenerator(function* () {
      debug('listLocalFiles');
      const localHostingFiles = _this12.path ? yield (0, _utils.getFiles)(_this12.path) : [];
      if (!Array.isArray(localHostingFiles)) return localHostingFiles;

      return localHostingFiles ? localHostingFiles.map(function (file) {
        return new HostingFile().loadLocal({
          localPath: file.fullPath,
          path: file.internalPath
        });
      }) : [];
    })();
  }

  listFiles() {
    var _this13 = this;

    return _asyncToGenerator(function* () {
      const remoteFiles = yield _this13.listRemoteFiles();
      const listLocalFiles = yield _this13.listLocalFiles();

      const files = [];
      listLocalFiles.forEach(function (file) {
        const remoteCopy = _lodash2.default.find(remoteFiles, { path: file.path });

        if (remoteCopy) {
          file.isUpToDate = file.checksum === remoteCopy.checksum;
          file.isSynced = true;
          _lodash2.default.extend(file, remoteCopy);
        }
        files.push(file);
      });
      return files;
    })();
  }

  getCNAME() {
    return _lodash2.default.find(this.remote.domains, domain => domain.indexOf('.') !== -1);
  }

  getCnameURL() {
    const cname = this.getCNAME();
    if (cname) {
      return `http://${cname}`;
    }
  }

  getRemote() {
    debug('getRemote()', this);
    return _session2.default.connection.hosting.get(this.name);
  }
}

exports.default = Hosting;
exports.HostingFile = HostingFile;
//# sourceMappingURL=hosting.js.map