'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _klawSync = require('klaw-sync');

var _klawSync2 = _interopRequireDefault(_klawSync);

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _findKey = require('find-key');

var _findKey2 = _interopRequireDefault(_findKey);

var _md = require('md5');

var _md2 = _interopRequireDefault(_md);

var _jsYaml = require('js-yaml');

var _jsYaml2 = _interopRequireDefault(_jsYaml);

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _formData = require('form-data');

var _formData2 = _interopRequireDefault(_formData);

var _archiver = require('archiver');

var _archiver2 = _interopRequireDefault(_archiver);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _es6TemplateStrings = require('es6-template-strings');

var _es6TemplateStrings2 = _interopRequireDefault(_es6TemplateStrings);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _sourceMap = require('source-map');

var _sourceMap2 = _interopRequireDefault(_sourceMap);

var _ws = require('ws');

var _ws2 = _interopRequireDefault(_ws);

var _yauzl = require('yauzl');

var _yauzl2 = _interopRequireDefault(_yauzl);

var _validate = require('@syncano/validate');

var _validate2 = _interopRequireDefault(_validate);

var _debug = require('../debug');

var _debug2 = _interopRequireDefault(_debug);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

var _hosting = require('../hosting');

var _hosting2 = _interopRequireDefault(_hosting);

var _printTools = require('../print-tools');

var _templates = require('../templates');

var _errors = require('../errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const { debug } = (0, _debug2.default)('utils-sockets');

class MetadataObject {
  constructor(name, metadata, socketName) {
    this.name = name;
    this.metadata = metadata;
    this.socketName = socketName;
    this.existRemotely = null;
    this.existLocally = null;
  }
  getStatus() {
    if (this.existLocally && this.existRemotely) {
      return { status: 'synced', type: 'ok' };
    }

    if (this.existLocally && !this.existRemotely) {
      return { status: 'not synced', type: 'warn' };
    }

    if (!this.existLocally && this.existRemotely) {
      return { status: 'no local configuration', type: 'fail' };
    }
  }
}

class Endpoint extends MetadataObject {
  call(params) {
    return _axios2.default.request({
      url: this.getURL(),
      method: 'POST',
      timeout: 3000,
      params,
      // Do not transform data automaticaly
      transformResponse: data => data
    });
  }

  getFullName() {
    return `${this.socketName}/${this.name}`;
  }

  getURL() {
    return `https://${_session2.default.getSpaceHost()}/${this.socketName}/${this.name}/`;
  }
}

class Handler extends MetadataObject {}

class Event extends MetadataObject {}

class Component extends MetadataObject {
  constructor(name, metadata, socketName) {
    super(name, metadata, socketName);
    this.componentPath = _path2.default.join(Socket.getLocal(this.socketName).socketPath, this.metadata.path);
    this.packageName = this.getRealName();
  }
  getRealName() {
    debug('getRealComponentName');
    return JSON.parse(_fs2.default.readFileSync(_path2.default.join(this.componentPath, 'package.json'))).name;
  }

  linkWithProject(projectPath) {
    debug('linkWithProject');
    _child_process2.default.spawnSync('yarn', ['link'], {
      cwd: this.componentPath,
      maxBuffer: 2048 * 1024,
      stdio: [process.stdio, 'pipe', 'pipe']
    });
    _child_process2.default.spawnSync('yarn', ['link', this.packageName], {
      cwd: projectPath,
      maxBuffer: 2048 * 1024,
      stdio: [process.stdio, 'pipe', 'pipe']
    });
  }

  isComponentFile(filePath) {
    return filePath.includes(_path2.default.join(this.componentPath, 'src'));
  }

  build() {
    var _this = this;

    debug(`component build: ${this.packageName}`);

    return new _bluebird2.default((() => {
      var _ref = _asyncToGenerator(function* (resolve, reject) {
        const command = 'npm';
        const args = 'run build -s';

        process.env.FORCE_COLOR = true;
        const out = _child_process2.default.spawnSync(command, args.split(' '), {
          cwd: _this.componentPath,
          maxBuffer: 2048 * 1024,
          stdio: [process.stdio, 'pipe', 'pipe']
        });

        if (out.status !== 0) {
          reject(new _errors.CompileError(out.stderr.toString()));
        } else {
          resolve();
        }
      });

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    })());
  }
}

class Socket {
  constructor(socketName, socketPath) {
    debug('Sockets.constructor', socketName);
    this.name = socketName;
    this.settings = { loaded: false };
    this.socketPath = socketPath || _utils2.default.findLocalPath(socketName);

    if (this.socketPath) {
      this.settings = _session2.default.settings.getSocketSettings(this.socketPath, this.name);
    }

    this.existRemotely = null;
    this.existLocally = null;
    this.fromNPM = null;

    // that looks stupid
    this.remote = {
      spec: {
        endpoints: {},
        event_handlers: {},
        events: {},
        components: {}
      },
      metadata: {}
    };

    this.spec = {
      spec: {
        endpoints: {},
        event_handlers: {},
        events: {},
        components: {}
      }
    };

    this.loadLocal();
  }

  isDependency() {
    debug('isDependency');
    // TODO: better way to dermine that?
    if (this.socketPath.match(/node_modules/)) {
      return true;
    }
  }

  static getTemplatesChoices() {
    return _utils2.default.getTemplatesChoices();
  }

  static uninstall(socket = {}) {
    debug('uninstall', socket.name);

    if (socket.existLocally && socket.localPath) {
      Socket.uninstallLocal(socket);
      if (socket.existRemotely) {
        this.uninstallRemote(socket.name);
      }
      return _bluebird2.default.resolve();
    }

    if (socket.existRemotely) {
      return this.uninstallRemote(socket.name);
    }

    return _bluebird2.default.reject(new Error('Socket with given doesn\'t exist!'));
  }

  static uninstallLocal(socket) {
    _utils2.default.deleteFolderRecursive(socket.localPath);
  }

  // TODO: check if the socket is installed (it may be not yet installed yet (before sync))
  static uninstallRemote(socketName) {
    return _asyncToGenerator(function* () {
      debug('uninstallRemote', socketName);
      return _session2.default.connection.socket.delete(socketName);
    })();
  }

  // list sockets based on call to Syncano (sockets are installed on Synano)
  static listRemote() {
    debug('listRemote()');
    return _session2.default.connection.socket.list();
  }

  // list all sockets (mix of locally definde and installed on server)
  static list() {
    return _asyncToGenerator(function* () {
      debug('list()');
      // Local Socket defined in folders and in project deps
      const localSocketsList = _utils2.default.listLocal();
      return _bluebird2.default.all(localSocketsList.map(function (socketName) {
        return Socket.get(socketName);
      }));
    })();
  }

  // Creating Socket simple object
  static getLocal(socketName) {
    debug('getLocal');
    return new Socket(socketName);
  }

  static get(socketName) {
    return _asyncToGenerator(function* () {
      debug(`Getting Socket: ${socketName}`);
      const socket = Socket.getLocal(socketName);
      yield socket.loadRemote();
      return socket;
    })();
  }

  static create(socketName, templateName) {
    debug('create socket', socketName, templateName);
    const newSocketPath = _path2.default.join(_session2.default.projectPath, 'syncano', socketName);
    const socket = new Socket(socketName, newSocketPath);
    if (socket.existLocally) {
      return _bluebird2.default.reject(new Error('Socket with given name already exist!'));
    }
    return socket.init(templateName);
  }

  init(templateName) {
    debug('init', templateName);
    return new _bluebird2.default((resolve, reject) => {
      const socketPath = this.getSocketPath();
      if (!_fs2.default.existsSync(socketPath)) {
        _mkdirp2.default.sync(socketPath);
      }

      try {
        const templateFolder = _path2.default.normalize((0, _templates.getTemplate)(templateName));
        const files = (0, _klawSync2.default)(templateFolder, { nodir: true });
        files.forEach(file => {
          const oldContent = _fs2.default.readFileSync(file.path, 'utf8');
          const socket = {
            socketName: this.name,
            socketDescription: `Description of ${this.name}`
          };

          const newContent = (0, _es6TemplateStrings2.default)(oldContent, socket, { partial: true });
          const fileToSave = _path2.default.join(socketPath, file.path.replace(templateFolder, ''));

          _mkdirp2.default.sync(_path2.default.parse(fileToSave).dir);
          _fs2.default.writeFileSync(_path2.default.join(socketPath, file.path.replace(templateFolder, '')), newContent);
        });
        resolve(this);
      } catch (err) {
        return reject(err);
      }
    });
  }

  verifySchema() {
    // Reload local settings
    if (this.settings.load) this.settings.load();
    return _validate2.default.validateMainSchema(this.settings.attributes);
  }

  verify() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      if (!_fs2.default.existsSync(_this2.getSrcFolder())) {
        throw new Error('No src folder!');
      }
      _this2.verifySchema();
    })();
  }

  getFullConfig() {
    return this.settings.getFull();
  }

  getRemote() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      debug('getRemote', _this3.name);
      try {
        return yield _session2.default.connection.socket.get(_this3.name);
      } catch (err) {
        return false;
      }
    })();
  }

  getRemoteSpec() {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      debug('getRemoteSpec');
      if (_this4.remote.files['socket.yml']) {
        try {
          const spec = yield _axios2.default.request({
            url: _this4.remote.files['socket.yml'].file,
            method: 'GET',
            timeout: 3000
          });
          _this4.remote.spec = _jsYaml2.default.load(spec.data);
        } catch (err) {}
      }
    })();
  }

  setRemoteState(socket) {
    this.existRemotely = true;
    this.remote.name = socket.name;
    this.remote.environment = socket.environment;
    this.remote.version = socket.version;
    this.remote.updatedAt = socket.updated_at;
    this.remote.installed = socket.installed;
    this.remote.files = socket.files;
    this.remote.status = socket.status;
    this.remote.statusInfo = socket.status_info;
    this.remote.config = socket.config;
    this.remote.metadata = socket.metadata;
  }

  loadRemote() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      debug('loadRemote()');
      const socket = yield _this5.getRemote();
      if (socket) {
        yield _this5.setRemoteState(socket);
        yield _this5.getRemoteSpec();
      } else {
        _this5.existRemotely = false;
      }
      return _this5;
    })();
  }

  loadLocal() {
    debug('loadLocal()');
    if (this.settings.loaded) {
      this.existLocally = true;
      this.localPath = this.settings.baseDir;
      this.spec = this.settings.getFull();
      if (this.localPath.indexOf('node_modules') > -1) {
        this.fromNPM = true;
      }
    }
  }

  isSocketFile(fileFullPath) {
    debug('isSocketFile', fileFullPath);
    return fileFullPath.includes(this.localPath);
  }

  getRawStatus() {
    return {
      existRemotely: this.existRemotely,
      existLocally: this.existLocally
    };
  }

  getStatus() {
    if (this.existLocally && !this.existRemotely) {
      return { status: 'not synced', type: 'warn' };
    }

    let msg = this.remote.statusInfo || this.remote.status;
    if (msg && msg.error) {
      msg = msg.error;
    }

    if (this.remote.status === 'ok') {
      return { status: msg, type: 'ok' };
    } else if (this.remote.status === 'processing') {
      return { status: msg, type: 'warn' };
    }
    return { status: msg, type: 'fail' };
  }

  getType() {
    if (this.existLocally) {
      if (this.fromNPM) {
        return { msg: 'installed via NPM', type: 'ok' };
      }
      return { msg: 'local Socket', type: 'ok' };
    }

    return { msg: 'no local configuration', type: 'warn' };
  }

  getVersion() {
    return this.remote ? this.remote.version : null;
  }

  getScripts() {
    return (0, _findKey2.default)(this.spec, 'file');
  }

  getSrcFolder() {
    return _path2.default.join(this.getSocketPath(), 'src', _path2.default.sep);
  }

  getCompiledScriptsFolder() {
    const folder = _path2.default.join(this.getSocketPath(), '.dist', 'src', _path2.default.sep);
    if (!_fs2.default.existsSync(folder)) {
      _mkdirp2.default.sync(folder);
    }
    return folder;
  }

  getSocketZipPath() {
    const folder = _path2.default.join(this.getSocketPath(), '.zip');
    if (!_fs2.default.existsSync(folder)) {
      _mkdirp2.default.sync(folder);
    }
    return folder;
  }

  getSocketZip() {
    debug('getSocketZip');
    return _path2.default.join(this.getSocketZipPath(), 'src.zip');
  }

  getSocketEnvZip() {
    debug('getSocketEnvZip');
    return _path2.default.join(this.getSocketZipPath(), 'env.zip');
  }

  isEmptyEnv() {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      debug('isEmptyEnv');
      if (_fs2.default.existsSync(_this6.getSocketEnvZip())) {
        const envZipFiles = yield _this6.listZipFiles(_this6.getSocketEnvZip());
        return !(envZipFiles.length > 0);
      }
      return true;
    })();
  }

  getSocketNodeModulesChecksum() {
    debug('getSocketNodeModulesChecksum');
    if (_fs2.default.existsSync(this.getSocketEnvZip())) {
      return (0, _md2.default)(_fs2.default.readFileSync(this.getSocketEnvZip()));
    }
    return 'none';
  }

  getSocketSourcesZipChecksum() {
    debug('getSocketSourcesZipChecksum');
    if (_fs2.default.existsSync(this.getSocketEnvZip())) {
      return (0, _md2.default)(_fs2.default.readFileSync(this.getSocketZip()));
    }
    return 'none';
  }

  getSocketConfigFile() {
    return _path2.default.join(_session2.default.projectPath, this.name, 'socket.yml');
  }

  composeFromSpec(objectType, ObjectClass) {
    debug('composeFromSpec', objectType, ObjectClass);
    const objects = Object.assign({}, this.remote.spec[objectType]);
    Object.assign(objects, this.spec[objectType]);

    debug('objects to process', objects);
    return Object.keys(objects).map(objectName => {
      debug(`checking ${objectName}`);
      const objectMetadata = objects[objectName];
      debug('objectMetadata', objectMetadata);
      const object = new ObjectClass(objectName, objectMetadata, this.name);

      debug('existRemotely', this.remote.spec[objectType], objectName);
      if (this.remote.spec[objectType][objectName]) {
        debug(`existRemotely: ${true}`);
        object.existRemotely = true;
      }

      if (this.spec[objectType] && this.spec[objectType][objectName]) {
        object.existLocally = true;
      }
      return object;
    });
  }

  composeComponentsFromSpec(objectType, ObjectClass) {
    debug('composeComponentsFromSpec', objectType, ObjectClass);
    const objects = Object.assign({}, this.spec[objectType]);
    Object.assign(objects, this.spec[objectType]);

    debug('objects to process', objects);
    return Object.keys(objects).map(objectName => {
      debug(`checking ${objectName}`);
      const objectMetadata = objects[objectName];
      debug('objectMetadata', objectMetadata);
      const object = new ObjectClass(objectName, objectMetadata, this.name);
      return object;
    });
  }

  getEndpoints() {
    debug('getEndpoints');
    return this.composeFromSpec('endpoints', Endpoint);
  }

  getEndpoint(endpointName) {
    debug('getEndpoints');
    return _lodash2.default.find(this.getEndpoints(), { name: endpointName });
  }

  getEventHandlers() {
    debug('getEventHandlers');
    return this.composeFromSpec('event_handlers', Handler);
  }

  getEvents() {
    debug('getEvents');
    return this.composeFromSpec('events', Event);
  }

  getEndpointTrace(endpointName, traceId) {
    return _session2.default.connection.trace.get(this.name, endpointName, traceId);
  }

  getEndpointTraces(endpointName, lastId) {
    var _this7 = this;

    return _asyncToGenerator(function* () {
      debug('getEndpointTraces', endpointName, lastId);
      try {
        const traces = yield _session2.default.connection.trace.get(_this7.name, endpointName);
        if (!lastId) {
          return traces;
        }
        const filteredTraces = [];
        traces.forEach(function (trace) {
          if (trace.id > lastId) {
            filteredTraces.push(trace);
          }
        });
        return filteredTraces;
      } catch (err) {}
    })();
  }

  getTraces(lastId) {
    const url = [`https://${_session2.default.getHost()}/v2/instances/${_session2.default.project.instance}/channels/eventlog/poll/`, '?transport=websocket', `&api_key=${_session2.default.settings.account.getAuthKey()}`, `&room=${`socket:${this.name}`}`].join('');

    return new _ws2.default(url);
  }

  static getEndpointTraceByUrl(url) {
    return _asyncToGenerator(function* () {
      const resp = yield _axios2.default.request({
        url: `https://${_session2.default.getHost()}${url}`,
        method: 'GET',
        headers: {
          'X-Api-Key': _session2.default.settings.account.getAuthKey()
        }
      });
      return resp.data;
    })();
  }

  getComponents() {
    var _this8 = this;

    return _asyncToGenerator(function* () {
      debug('getComponents');
      debug('getEndpoints');
      return _this8.composeComponentsFromSpec('components', Component);
    })();
  }

  listZipFiles(zipPath) {
    debug('listZipFiles', zipPath);
    const files = [];
    if (!_fs2.default.existsSync(zipPath)) {
      return files;
    }

    return new _bluebird2.default((resolve, reject) => {
      _yauzl2.default.open(zipPath, { lazyEntries: true }, (err, zipfile) => {
        if (err) {
          reject(err);
        }
        zipfile.readEntry();
        zipfile.on('end', entry => {
          resolve(files);
        });
        zipfile.on('entry', entry => {
          if (/\/$/.test(entry.fileName)) {
            // Directory file names end with '/'.
            // Note that entires for directories themselves are optional.
            // An entry's fileName implicitly requires its parent directories to exist.
            zipfile.readEntry();
          } else {
            // file entry
            files.push(entry.fileName);
            zipfile.readEntry();
          }
        });
      });
    });
  }

  getAllFiles() {
    // Ignore patterns from .syncanoignore file
    let ignore = [];
    try {
      ignore = _fs2.default.readFileSync(`${this.getCompiledScriptsFolder()}/.syncanoignore`, 'utf8').split('\n');
    } catch (err) {}

    return _glob2.default.sync(`**`, {
      cwd: this.getCompiledScriptsFolder(),
      ignore,
      realpath: true,
      nodir: true
    }).map(file => {
      return {
        fullPath: file,
        internalPath: file.replace(`${this.getCompiledScriptsFolder()}`, '')
      };
    });
  }

  createZip(params = { partial: true }) {
    var _this9 = this;

    return _asyncToGenerator(function* () {
      debug('createZip', params.partial);
      return new _bluebird2.default(function (resolve, reject) {
        const archive = (0, _archiver2.default)('zip', { zlib: { level: 9 } });
        const output = _fs2.default.createWriteStream(_this9.getSocketZip(), { mode: 0o700 });

        archive.pipe(output);
        archive.on('error', reject);

        // Adding socket.yml if needed
        const localYMLChecksum = (0, _md2.default)(_fs2.default.readFileSync(_this9.getSocketYMLFile()));
        const remoteYMLChecksum = _this9.remote.files && _this9.remote.files['socket.yml'] ? _this9.remote.files['socket.yml'].checksum : '';

        const addMetaFiles = function () {
          debug('Adding file to archive: \'socket.yml\'');
          archive.file(_this9.getSocketYMLFile(), { name: 'socket.yml' });
        };

        debug('Processing: \'socket.yml\'');
        if (params.partial) {
          if (remoteYMLChecksum !== localYMLChecksum) {
            addMetaFiles();
          } else {
            debug('Ignoring file: socket.yml');
          }
        } else {
          addMetaFiles();
        }

        const files = _this9.getAllFiles();

        // Adding all files (besides those filtered out)
        files.forEach(function (file) {
          // with "internal" path
          const fileNameWithPath = file.internalPath;
          const remoteFile = _this9.remote.files ? _this9.remote.files[fileNameWithPath] : null;

          if (remoteFile && params.partial) {
            if (remoteFile.checksum !== (0, _md2.default)(_fs2.default.readFileSync(file.fullPath))) {
              debug(`Adding file to archive: ${fileNameWithPath}`);
              archive.file(file.fullPath, { name: fileNameWithPath });
            } else {
              debug(`Not adding file to archive (same checksum): ${fileNameWithPath}`);
            }
          } else {
            archive.file(file.fullPath, { name: fileNameWithPath });
          }
        });
        archive.finalize();

        output.on('close', function () {
          resolve();
        });
      });
    })();
  }

  createEnvZip() {
    debug('createEnvZip');
    return new _bluebird2.default((resolve, reject) => {
      const output = _fs2.default.createWriteStream(this.getSocketEnvZip(), { mode: 0o700 });
      const archive = (0, _archiver2.default)('zip', { zlib: { level: 9 } });

      const envFolder = _path2.default.join(this.getSocketPath(), '.dist', 'node_modules');

      if (!_fs2.default.existsSync(envFolder)) {
        _mkdirp2.default.sync(envFolder);
      }

      let filesInZip = 0;

      archive.pipe(output);
      archive.on('error', reject);

      const files = _glob2.default.sync(`**`, {
        cwd: envFolder,
        dot: true,
        follow: true,
        nodir: true
      });

      files.forEach(file => {
        archive.file(_path2.default.join(envFolder, file), { name: _path2.default.join('node_modules', file) });
        filesInZip += 1;
      });

      if (filesInZip) {
        archive.finalize();
      } else {
        _fs2.default.unlinkSync(this.getSocketEnvZip());
        resolve(false);
      }

      output.on('close', () => {
        resolve(true);
      });
    });
  }

  updateEnvCall(method) {
    var _this10 = this;

    return _asyncToGenerator(function* () {
      debug('updateEnvCall');
      if (yield _this10.isEmptyEnv()) {
        return;
      }

      return new _bluebird2.default(function (resolve, reject) {
        const form = new _formData2.default();

        let endpointPath = `/v2/instances/${_session2.default.project.instance}/environments/`;
        if (method === 'PATCH') {
          endpointPath = `/v2/instances/${_session2.default.project.instance}/environments/${_this10.name}/`;
        }

        debug('endpointPath', endpointPath);
        form.append('name', _this10.name);
        form.append('metadata', JSON.stringify({ checksum: _this10.getSocketNodeModulesChecksum() }));
        form.append('zip_file', _fs2.default.createReadStream(_this10.getSocketEnvZip()));
        debug('upload env zip');
        form.submit({
          method,
          protocol: 'https:',
          host: _session2.default.getHost(),
          headers: {
            'X-Api-Key': _session2.default.settings.account.getAuthKey()
          },
          path: endpointPath

        }, function (err, res) {
          debug('end env upload');
          if (res.statusCode === 200) {
            resolve();
          }

          if (res.statusCode === 413) {
            debug('error while updating environment - environment is to big :(');
            return reject(new Error('environment is to big'));
          }

          if (err || res.statusCode === 404) {
            debug(`environment ${_this10.name} was not found`);
            return reject(err || res);
          }

          res.on('data', function (data) {
            const message = data.toString();

            if (res.statusCode > 299) {
              debug(`error while updating environment (${res.statusCode})`);
              return reject(message);
            }

            debug(`environment ${_this10.name} was found`);
            resolve(message);
          });
        });
      });
    })();
  }

  updateEnv() {
    var _this11 = this;

    return _asyncToGenerator(function* () {
      debug('updateEnv');
      const resp = yield _this11.socketEnvShouldBeUpdated();
      if (resp) {
        if (!_this11.isDependency()) {
          yield _this11.createEnvZip();
        }
        return _this11.updateEnvCall(resp);
      }
      return 'No need to update';
    })();
  }

  updateSocketZip({ config, install = false }) {
    var _this12 = this;

    return _asyncToGenerator(function* () {
      debug('updateSocketZip');
      let endpointPath = `/v2/instances/${_session2.default.project.instance}/sockets/`;

      if (!install) {
        endpointPath += `${_this12.name}/`;
      }

      const zipFiles = yield _this12.listZipFiles(_this12.getSocketZip());
      const allFiles = yield _this12.getAllFiles().map(function (file) {
        return file.internalPath;
      });
      const numberOfFiles = zipFiles.length;

      if (numberOfFiles === 0 && _this12.isConfigSynced(config)) {
        debug('config is synced and nothing to update');
        return _bluebird2.default.resolve();
      }
      debug('preparing update');

      return new _bluebird2.default((() => {
        var _ref2 = _asyncToGenerator(function* (resolve, reject) {
          const form = new _formData2.default();

          form.append('name', _this12.name);

          if (yield _this12.isEmptyEnv()) {
            debug('environment is null');
            form.append('environment', '');
          } else {
            form.append('environment', _this12.name);
          }

          if (config) {
            form.append('config', JSON.stringify(config));
          }

          const metadata = Object.assign({}, _this12.remote.metadata);
          form.append('metadata', JSON.stringify(metadata));

          debug('zip_file_list', allFiles);
          form.append('zip_file_list', JSON.stringify(allFiles));

          if (numberOfFiles > 0) {
            form.append('zip_file', _fs2.default.createReadStream(_this12.getSocketZip()));
          }

          form.submit({
            method: install ? 'POST' : 'PATCH',
            protocol: 'https:',
            host: _session2.default.getHost(),
            headers: {
              'X-Api-Key': _session2.default.settings.account.getAuthKey()
            },
            path: endpointPath

          }, function (err, res) {
            debug('end upload');
            let responseData = '';
            let responseCode = '';
            res.on('data', function (data) {
              responseData += data.toString();
              responseCode = res.statusCode;
            });
            res.on('end', function () {
              if (err || responseCode === 404) {
                debug(`socket ${_this12.name} was not found`);
                return reject(err || res);
              }

              if (responseCode > 299) {
                debug(`error while updating socket (${res.statusCode})`);
                return reject(responseData);
              }

              debug(`socket ${_this12.name} was found`);
              resolve(responseData);
            });
          });
        });

        return function (_x3, _x4) {
          return _ref2.apply(this, arguments);
        };
      })());
    })();
  }

  getSocketPath() {
    return this.socketPath;
  }

  getSocketYMLFile() {
    return _path2.default.join(this.getSocketPath(), 'socket.yml');
  }

  createAllZips() {
    var _this13 = this;

    return _asyncToGenerator(function* () {
      yield _this13.compile({ updateSocketNPMDeps: true });
      yield _this13.createEnvZip();
      yield _this13.createZip({ partial: false });
    })();
  }

  compile(params = { updateSocketNPMDeps: false }) {
    var _this14 = this;

    debug(`compile: ${this.name}`);
    debug(`compile socketPath: ${this.getSocketPath()}`);

    return new _bluebird2.default((() => {
      var _ref3 = _asyncToGenerator(function* (resolve, reject) {
        const command = 'npm';
        let args = null;

        if (params.updateSocketNPMDeps) {
          args = 'run build -s';
        } else {
          args = 'run build:src -s';
        }

        process.env.FORCE_COLOR = true;
        const out = _child_process2.default.spawnSync(command, args.split(' '), {
          cwd: _this14.getSocketPath(),
          maxBuffer: 2048 * 4096,
          stdio: [process.stdio, 'pipe', 'pipe']
        });

        if (out.status !== 0) {
          reject(new _errors.CompileError(out.stderr.toString()));
        } else {
          resolve();
        }
      });

      return function (_x5, _x6) {
        return _ref3.apply(this, arguments);
      };
    })());
  }

  build() {
    var _this15 = this;

    debug(`socket build: ${this.name}`);

    return new _bluebird2.default((() => {
      var _ref4 = _asyncToGenerator(function* (resolve, reject) {
        const command = 'npm';
        const args = 'install';

        process.env.FORCE_COLOR = true;
        const out = _child_process2.default.spawnSync(command, args.split(' '), {
          cwd: _this15.socketPath,
          maxBuffer: 2048 * 1024,
          stdio: [process.stdio, 'pipe', 'pipe']
        });

        if (out.status !== 0) {
          reject(new _errors.CompileError(out.stderr.toString()));
        } else {
          resolve();
        }
      });

      return function (_x7, _x8) {
        return _ref4.apply(this, arguments);
      };
    })());
  }

  isConfigSynced(config) {
    debug('isConfigSynced');
    return _lodash2.default.isEqual(config, this.remote.config);
  }

  updateConfig(config) {
    if (this.isConfigSynced(config)) {
      return _bluebird2.default.resolve();
    }
    return _axios2.default.request({
      url: `https://${_session2.default.getHost()}/v2/instances/${_session2.default.project.instance}/sockets/${this.name}/`,
      method: 'PATCH',
      data: { config },
      headers: {
        'X-Api-Key': _session2.default.settings.account.getAuthKey()
      }
    });
  }

  update(params = { config: null, updateSocketNPMDeps: false, updateEnv: false }) {
    var _this16 = this;

    return _asyncToGenerator(function* () {
      debug(`Socket update: ${_this16.name}`, params);
      const config = Object.assign({}, _this16.remote.config, params.config);

      // Get options from the env
      if (_this16.spec.config) {
        Object.keys(_this16.spec.config).forEach(function (optionName) {
          const envValue = _this16.getConfigOptionFromEnv(optionName);
          if (envValue) {
            debug(`setting value from env for: ${optionName}`);
            config[optionName] = envValue;
          }
        });
      }

      yield _this16.verify();
      if (!_this16.isDependency()) {
        yield _this16.compile({ updateSocketNPMDeps: params.updateSocketNPMDeps });
        yield _this16.createZip();
      }

      if (params.updateEnv) {
        yield _this16.updateEnv();
      }

      let resp = null;
      if (_this16.existRemotely) {
        resp = yield _this16.updateSocketZip({ config, install: false });
      } else {
        resp = yield _this16.updateSocketZip({ config, install: true });
      }

      if (resp && resp.status !== 'ok') return _this16.waitForStatusInfo();
      return { status: 'stopped' };
    })();
  }

  waitForStatusInfo() {
    var _this17 = this;

    debug('waitForStatusInfo');

    return new _bluebird2.default((resolve, reject) => {
      const getStatus = (() => {
        var _ref5 = _asyncToGenerator(function* () {
          const socket = yield _this17.getRemote();
          if (socket.status !== 'ok' && socket.status !== 'error') {
            setTimeout(getStatus, 200);
          } else {
            _this17.setRemoteState(socket);
            resolve({ status: socket.status, message: socket.status_info });
          }
        });

        return function getStatus() {
          return _ref5.apply(this, arguments);
        };
      })();
      getStatus();
    });
  }

  // Hosting
  addHosting(hostingName, params) {
    this.settings.addHosting(hostingName, params);
    this.settings.save();
  }

  getHosting(hostingName) {
    return _hosting2.default.get(this, hostingName);
  }

  listHostings() {
    return _hosting2.default.list(this);
  }

  deleteHosting(hostingName) {
    this.settings.deleteHosting(hostingName);
    this.settings.save();
    (0, _printTools.echo)();
    (0, _printTools.echo)(4)(`Hosting ${hostingName} of ${this.name} has been deleted from config...`);
  }

  getScriptObject(fileFullPath) {
    const srcFile = fileFullPath;
    const compiledFile = fileFullPath.replace(this.getSrcFolder(), this.getCompiledScriptsFolder());
    return {
      srcFile,
      compiledFile
    };
  }

  getFileForEndpoint(endpointName) {
    if (endpointName.startsWith('events')) {
      return this.spec.event_handlers[endpointName].file;
    }
    return this.spec.endpoints[endpointName].file;
  }

  getSourceMapPath(endpointName) {
    const filePath = this.getFileForEndpoint(endpointName);
    const { base, dir } = _path2.default.parse(filePath);
    return _path2.default.join(this.getSocketPath(), dir, '.bundles', `${base}.map`);
  }

  getOrigFileLine(traceData, endpointName) {
    const smc = new _sourceMap2.default.SourceMapConsumer(_fs2.default.readFileSync(this.getSourceMapPath(endpointName), { encoding: 'utf-8' }));
    return smc.originalPositionFor({
      line: traceData.lineNumber,
      column: traceData.columnNumber
    });
  }

  getPrettyTrace(traceData, endpointName) {
    const origFileLine = this.getOrigFileLine(traceData, endpointName);
    const origFilePath = _utils2.default.getOrigFilePath(origFileLine);

    return {
      origFilePath,
      lineNumber: origFileLine.line,
      columnNumber: origFileLine.column,
      lines: [_fs2.default.readFileSync(
      // origFilePath,
      _path2.default.join(this.getSocketPath(), '../', origFilePath), { encoding: 'utf-8' }).split('\n')[origFileLine.line - 1], (0, _printTools.p)(origFileLine.column)('^')]
    };
  }

  // Config
  getConfigOptions() {
    return this.spec.config;
  }

  getConfigOptionFromEnv(optionName) {
    const socketVarName = this.name.replace('-', '_').toUpperCase();
    const optionVarName = optionName.replace('-', '_').toUpperCase();
    return process.env[`${socketVarName}__${optionVarName}`] || process.env[`${socketVarName}_${optionVarName}`];
  }

  getConfigOptionsToAsk() {
    // If there is not options in spec it is always no options to ask
    if (this.spec && !this.spec.config) {
      return {};
    }

    const options = {};

    if (this.existLocally) {
      Object.keys(this.spec.config).forEach(optionName => {
        const envValue = this.getConfigOptionFromEnv(optionName);
        const option = this.spec.config[optionName];
        if (option.required && !envValue) {
          if (!this.remote.config || !this.remote.config[optionName]) {
            options[optionName] = option;
          }
        }
      });
      return options;
    }
  }

  socketEnvShouldBeUpdated() {
    var _this18 = this;

    return _asyncToGenerator(function* () {
      debug('socketEnvShouldBeUpdated');
      try {
        const resp = yield _axios2.default.request({
          url: `https://${_session2.default.getHost()}/v2/instances/${_session2.default.project.instance}/environments/${_this18.name}/`,
          method: 'GET',
          timeout: 50000,
          headers: {
            'X-Api-Key': _session2.default.settings.account.getAuthKey()
          }
        });

        if (resp.data.metadata.checksum === _this18.getSocketNodeModulesChecksum()) {
          debug('socketEnvShouldBeUpdated', 'env is up to date');
          return false;
        }
        return 'PATCH';
      } catch (err) {
        return 'POST';
      }
    })();
  }

  isCompatible() {
    const socketMajorVersion = this.spec.version.split('.')[0];
    if (socketMajorVersion !== _session2.default.majorVersion) {
      throw new _errors.CompatibilityError(socketMajorVersion, _session2.default.majorVersion);
    }
    return true;
  }
}

Socket.listLocal = _utils2.default.listLocal;

exports.default = Socket;
module.exports = exports['default'];
//# sourceMappingURL=sockets.js.map