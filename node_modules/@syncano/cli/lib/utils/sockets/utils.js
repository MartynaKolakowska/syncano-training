'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _jsYaml = require('js-yaml');

var _jsYaml2 = _interopRequireDefault(_jsYaml);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _walkdir = require('walkdir');

var _walkdir2 = _interopRequireDefault(_walkdir);

var _debug = require('../debug');

var _debug2 = _interopRequireDefault(_debug);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _templates = require('../templates');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const { debug } = (0, _debug2.default)('utils-sockets-utils');

const socketTemplates = () => {
  const installedTemplatesNames = (0, _templates.installedSocketTemplates)();
  const allTemplatesNames = _templates.builtInSocketTemplates.concat(installedTemplatesNames);

  const installedTemplates = allTemplatesNames.map(templateName => {
    debug('loading template:', templateName);
    const templateSpec = (0, _templates.getTemplateSpec)(templateName);

    return { name: templateName, description: templateSpec.templateLongDesc };
  });
  return installedTemplates;
};

const getTemplatesChoices = () => socketTemplates().map(socketTemplate => `${socketTemplate.description} - ${_chalk2.default.grey(`(${socketTemplate.name})`)}`);

const searchForSockets = (socketsPath, maxDepth = 3) => {
  if (!_fs2.default.existsSync(socketsPath)) {
    return [];
  }
  const sockets = [];

  const options = {
    'follow_symlinks': true,
    'max_depth': maxDepth

    // TODO: optimize only diging deeper scoped modues
  };_walkdir2.default.sync(socketsPath, options, (walkPath, stat) => {
    if (walkPath.match(/socket.yml$/) && !_path2.default.dirname(walkPath).match(/\/\./)) {
      const socket = _jsYaml2.default.load(_fs2.default.readFileSync(walkPath, 'utf8')) || {};
      sockets.push([walkPath, socket]);
    }
  });

  return sockets;
};

const findLocalPath = socketName => {
  debug('findLocalPath');
  let socketPath = null;
  const projectPath = _session2.default.projectPath || process.cwd();

  if (!_fs2.default.existsSync(projectPath)) {
    return socketPath;
  }

  const socketInCurrentPath = _path2.default.join(projectPath, 'socket.yml');
  if (_fs2.default.existsSync(socketInCurrentPath)) {
    const socket = _jsYaml2.default.load(_fs2.default.readFileSync(socketInCurrentPath, 'utf8')) || {};
    if (socket.name === socketName) {
      return _path2.default.dirname(socketInCurrentPath);
    }
  }

  // Search for syncano folder
  const socketsPath = _path2.default.join(_session2.default.projectPath, 'syncano');
  searchForSockets(socketsPath).forEach(([file, socket]) => {
    if (socket.name === socketName) {
      socketPath = _path2.default.dirname(file);
    }
  });

  if (!socketPath) {
    const nodeModPath = _path2.default.join(_session2.default.projectPath, 'node_modules');
    searchForSockets(nodeModPath).forEach(([file, socket]) => {
      if (socket.name === socketName) {
        socketPath = _path2.default.dirname(file);
      }
    });
  }

  return socketPath;
};

// Listing sockets
// list sockets based on project path
const listLocal = () => {
  debug('listLocal', _session2.default.projectPath);

  const singleSocketPath = _path2.default.join(_session2.default.projectPath);
  const singleSocket = searchForSockets(singleSocketPath, 1).map(([file, socket]) => socket.name);

  const localPath = _path2.default.join(_session2.default.projectPath, 'syncano');
  const localSockets = searchForSockets(localPath).map(([file, socket]) => socket.name);

  const nodeModPath = _path2.default.join(_session2.default.projectPath, 'node_modules');
  const nodeModSockets = searchForSockets(nodeModPath).map(([file, socket]) => socket.name);

  return localSockets.concat(singleSocket, nodeModSockets);
};

const getOrigFilePath = origFileLine => {
  let origFilePath = origFileLine.source.match(/webpack:\/\/\/(.*\.js)(\?|$)/)[1];

  if (origFilePath.match(/~\//)) {
    origFilePath = origFilePath.replace('~', 'node_modules');
  }
  return origFilePath;
};

const deleteFolderRecursive = folder => {
  if (_fs2.default.existsSync(folder)) {
    _fs2.default.readdirSync(folder).forEach((file, index) => {
      const curPath = _path2.default.join(folder, file);
      if (_fs2.default.lstatSync(curPath).isDirectory()) {
        // recurse
        deleteFolderRecursive(curPath);
      } else {
        _fs2.default.unlinkSync(curPath);
      }
    });
    _fs2.default.rmdirSync(folder);
  }
};

exports.default = {
  deleteFolderRecursive,
  getTemplatesChoices,
  findLocalPath,
  listLocal,
  getOrigFilePath
};
module.exports = exports['default'];
//# sourceMappingURL=utils.js.map